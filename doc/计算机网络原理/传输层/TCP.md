## TCP 的传输连接管理

传输连接有三个阶段：连接建立、数据传送和连接释放

TCP 连接的建立都是采用客户服务器方式

主动发起连接建立的应用进程叫做客户（client）

被动等待连接建立的应用进程叫做服务器（server）


### 三次握手建立TCP连接

![computer-51.png](/doc/imgs/computer/computer-51.png)

**为什么要第三个数据包进行确认？ - 为了防止已失效的连接请求报文段突然又传送到了B，因而产生错误。**

**已失效的连接请求报文段的产生情况：**
* A 发出的连接请求报文并没有丢失，而是在某些网络结点长时间滞留，以致延误到连接释放以后的某个时间才到达B。
* 本来这是一个早已失效的报文段，但B收到此失效的连接请求报文段后，误认为是A又发出一次新的连接请求，于是就
  向A发出确认报文段，同意建立连接。
* 假设不采用三次握手，那么只要B发出确认，新的连接就建立了。
* 由于现在A并没有发出建立连接的请求，因此不会理睬B的确认，也不会向B发送数据。
* 但B却以为新的运输连接已经建立，并一直等待A发来数据
* 结果：浪费了B的许多资源
 

### TCP四次挥手释放TCP连接

![computer-52.png](/doc/imgs/computer/computer-52.png)

* 数据传输结束后，通信的双方都可释放连接。现在A的应用进程先向其 TCP 发出连接释放报文段，并停止再发送数据，主动关闭TCP连接。 
  A 把连接释放报文段首部 FIN = 1，其序号 seq = u，等待 B 的确认
  
* B 发出确认，确认号 ack = u + 1，其序号为 seq = v；TCP 服务器进程通知高层应用进程。
  从 A 到 B 这个方向的连接就释放了，TCP 连接处于半关闭状态。 B 若发送数据，A 仍要接收。
  
* 若 B 已经没有要向 A 发送的数据，其应用进程就通知 TCP 释放连接。

* TCP 连接必须经过时间 2MSL 后才真正释放掉。【MSL（Maximum Segment Lifetime）- 最长报文段寿命 - 2min】

**A 在 TIME-WAIT 状态必须等待2MSL的时间？**
* **为了保证A发送的最后一个ACK报文段能够到达B**。因此 ACK 报文段很可能会丢失。
  B收不到确认，就会超时重传 FIN + ACK 报文段，而A就能在2MSL时间内收到这个重传报文段。
  接着，A再重传一次确认，重新启动 2MSL 计时器。最后 A 和 B 都能正常进入到 CLOSE状态。
* **防止“已失效的连接请求报文段”出现在本连接中。**
  A 在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。
  这样可以使下一个新的连接中不会出现这种旧的连接请报文段。







  




